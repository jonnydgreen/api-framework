// Copyright 2024-2024 the API framework authors. All rights reserved. MIT license.
import { eTag } from "@std/http/etag";
import { STATUS_CODE, STATUS_TEXT, type StatusCode } from "@std/http/status";
import type { Context } from "./context.ts";

// TODO(jonnydgreen): follow RFC https://www.rfc-editor.org/rfc/rfc9457.html

/**
 * An error response with a shape described by the
 * error details {@link https://www.rfc-editor.org/rfc/rfc9457.html | RFC-9457}.
 */
export interface ErrorResponse {
  /**
   * The HTTP status code of the error response. This is generated by the
   * origin server for this occurrence of the problem
   * @example
   * 200
   */
  status: StatusCode;
  /**
   * The title of the error response is a short, human-readable summary
   * of the problem type.
   */
  title: string;
  /**
   * The details of the error response is a human-readable explanation
   * specific to this occurrence of the problem.
   */
  detail: string;
}

/**
 * Build error response constructs an error response as described by
 * {@link https://www.rfc-editor.org/rfc/rfc9457.html | RFC-9457} from
 * a given error for a request.
 *
 * @param ctx The request context.
 * @param error The error to construct the response from.
 * @returns The error response parts which are used to build a Response instance.
 *
 * @example Usage
 * ```ts
 * import { buildErrorResponse, Context, ServerContext } from "@eyrie/app";
 * import { assert } from "@std/assert";
 *
 * const serverContext = new ServerContext("CRITICAL");
 * const request = new Request("http://example.com");
 * const ctx = new Context(serverContext, request)
 *
 * const [error] = buildErrorResponse(ctx, new Error('kaboom'));
 *
 * assert(error.status === 500);
 * assert(error.title === 'Internal Server Error');
 * assert(error.detail === 'kaboom');
 * ```
 */
export function buildErrorResponse(
  ctx: Context,
  error: unknown,
): [ErrorResponse, ResponseInit | undefined] {
  // TODO(jonnydgreen): type
  // TODO(jonnydgreen): instance
  // TODO(jonnydgreen): work out best way of exposing this
  const detail = (error instanceof Error ? error.message : undefined) ||
    String(error);
  // TODO(jonnydgreen): work out best way of customising this
  const status = getErrorStatusCode(error);
  // TODO(jonnydgreen): work out best way of customising this
  const title = STATUS_TEXT[status];
  const body: ErrorResponse = { status, title, detail };
  // TODO(jonnydgreen): JSON logs
  ctx.log.error(`Error running handler: ${detail}`);
  return [body, {
    headers: { "content-type": "application/problem+json" },
    status,
  }];
}

/**
 * Process the input parameters for instantiating a {@linkcode Response}
 * including auto-generated headers and body serialisation.
 *
 * @param ctx The request context
 * @param body The response body definition
 * @param init The response init options
 * @returns The instantiated {@linkcode Response}
 *
 * @example Usage
 * ```ts
 * import { processResponse, Context, ServerContext } from "@eyrie/app";
 * import { assert, assertEquals } from "@std/assert";
 *
 * const serverContext = new ServerContext("INFO");
 * const request = new Request("http://example.com");
 * const ctx = new Context(serverContext, request);
 * const body = { hello: 'there' };
 *
 * const response = await processResponse(ctx, body);
 * const json = await response.json();
 *
 * assert(response.status === 200);
 * assertEquals(json, body);
 * ```
 */
export async function processResponse(
  ctx: Context,
  body: Response | object | BodyInit | null,
  init?: ResponseInit,
): Promise<Response> {
  if (body instanceof Response) {
    return body;
  }
  const bodyInit = serialiseResponseBody(ctx, body);
  const headers = await createHeaders(ctx, bodyInit, init);
  return new Response(bodyInit, { ...init, headers });
}

function getErrorStatusCode(error: unknown): StatusCode {
  if (error && typeof error === "object" || error instanceof Error) {
    if (
      "statusCode" in error && typeof error.statusCode === "number"
    ) {
      if (error.statusCode in STATUS_TEXT) {
        return error.statusCode as StatusCode;
      }
    }
  }
  return STATUS_CODE.InternalServerError;
}

async function createHeaders(
  _ctx: Context,
  bodyInit: BodyInit | null | undefined,
  init: ResponseInit | undefined,
): Promise<Headers> {
  const headers = new Headers(init?.headers);

  await createEtagHeader(bodyInit, headers);

  return headers;
}

async function createEtagHeader(
  bodyInit: BodyInit | null | undefined,
  headers: Headers,
): Promise<void> {
  if (typeof bodyInit === "string") {
    const etag = await eTag(bodyInit);
    if (etag) {
      headers.set("etag", etag);
    }
  }
}

function serialiseResponseBody(
  _ctx: Context,
  body: object | BodyInit | null | undefined,
): BodyInit | null | undefined {
  let bodyInit: BodyInit | null | undefined = undefined;
  if (
    typeof body === "string" ||
    typeof body === "number" ||
    typeof body === "boolean"
  ) {
    bodyInit = String(body);
  } else if (typeof body === "object") {
    // TODO(jonnydgreen): handle content types here
    bodyInit = JSON.stringify(body);
  }
  return bodyInit;
}
